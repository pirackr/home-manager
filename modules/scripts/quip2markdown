#!/usr/bin/env python3
"""
quip2markdown - Simple Quip to Markdown converter

Fetches a Quip document and converts it to Markdown format.

Usage:
    export QUIP_TOKEN="your_token_here"
    quip2markdown <quip_url_or_id>

    Or:
    quip2markdown <quip_url_or_id> --token <token>

Examples:
    quip2markdown https://quip.com/XYZ123
    quip2markdown XYZ123
    quip2markdown XYZ123 --token mytoken
"""

import argparse
import json
import os
import re
import subprocess
import sys
import tempfile
import urllib.error
import urllib.parse
import urllib.request




def extract_thread_id(url_or_id):
    """Extract thread ID from URL or return as-is if already an ID"""
    # If it looks like a URL, extract the ID
    if 'quip.com' in url_or_id:
        # Match pattern: https://company.quip.com/XYZ123/doc-title
        match = re.search(r'quip\.com/([a-zA-Z0-9]+)', url_or_id)
        if match:
            return match.group(1)
    # Otherwise assume it's already an ID
    return url_or_id


def fetch_quip_html(thread_id, token):
    """Fetch HTML content from Quip API"""
    url = f"https://platform.quip.com/2/threads/{thread_id}/html"

    headers = {
        'Authorization': f'Bearer {token}'
    }

    req = urllib.request.Request(url, headers=headers)

    try:
        with urllib.request.urlopen(req) as response:
            data = json.loads(response.read().decode('utf-8'))
            return data.get('html', '')
    except urllib.error.HTTPError as e:
        if e.code == 401:
            print("ERROR: Invalid or missing QUIP_TOKEN", file=sys.stderr)
            print("\nTo get your personal access token:", file=sys.stderr)
            print("1. Go to https://quip.com/dev/token", file=sys.stderr)
            print("2. Generate a new token", file=sys.stderr)
            print("3. Set it: export QUIP_TOKEN='your_token'", file=sys.stderr)
        elif e.code == 404:
            print(f"ERROR: Document not found: {thread_id}", file=sys.stderr)
        else:
            print(f"ERROR: HTTP {e.code}", file=sys.stderr)
            try:
                error_body = e.read().decode('utf-8')
                print(error_body, file=sys.stderr)
            except:
                pass
        sys.exit(1)
    except urllib.error.URLError as e:
        print(f"ERROR: {e.reason}", file=sys.stderr)
        sys.exit(1)


def clean_quip_markdown(markdown):
    """Clean up Quip-specific quirks in markdown output"""
    # Remove zero-width spaces (U+200B) - Quip adds these everywhere
    markdown = markdown.replace('\u200b', '')

    # Replace non-breaking spaces with regular spaces
    markdown = markdown.replace('\xa0', ' ')

    # Remove trailing whitespace from lines (do this before other processing)
    lines = [line.rstrip() for line in markdown.split('\n')]

    # Remove consecutive blank lines (but keep one blank line)
    # Don't do this aggressively as it can mess up table formatting
    cleaned_lines = []
    prev_blank = False
    for line in lines:
        is_blank = not line.strip()
        if is_blank and prev_blank:
            continue  # Skip consecutive blank lines
        cleaned_lines.append(line)
        prev_blank = is_blank

    markdown = '\n'.join(cleaned_lines)

    return markdown


def html_to_markdown(html):
    """Convert HTML to Markdown using markdownify"""
    try:
        # Save HTML to temporary file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.html', delete=False) as f:
            f.write(html)
            html_file = f.name

        try:
            # Create a Python script that uses markdownify
            script = f"""
from markdownify import markdownify as md

with open('{html_file}', 'r') as f:
    html = f.read()

markdown = md(html, heading_style="ATX")
print(markdown)
"""
            # Use uv to run the script with markdownify
            result = subprocess.run(
                ['uv', 'run', '--with', 'markdownify', 'python3', '-c', script],
                capture_output=True,
                text=True,
                check=True
            )

            # Clean up Quip-specific quirks
            markdown = clean_quip_markdown(result.stdout)
            return markdown
        finally:
            # Clean up temporary file
            os.unlink(html_file)
    except subprocess.CalledProcessError as e:
        print(f"ERROR: Failed to convert HTML to Markdown: {e.stderr}", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError:
        print("ERROR: 'uv' command not found. Please install uv first.", file=sys.stderr)
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description='Convert Quip documents to Markdown',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    export QUIP_TOKEN="your_token"
    quip2markdown https://quip.com/XYZ123/doc-title
    quip2markdown XYZ123
    quip2markdown XYZ123 --token mytoken
        """
    )
    parser.add_argument('url_or_id', help='Quip URL or document ID')
    parser.add_argument('--token', help='Quip API token (or use QUIP_TOKEN env var)')

    args = parser.parse_args()

    # Get token from argument or environment
    token = args.token or os.environ.get('QUIP_TOKEN')

    if not token:
        print("ERROR: QUIP_TOKEN not found", file=sys.stderr)
        print("\nProvide token via:", file=sys.stderr)
        print("  1. Environment: export QUIP_TOKEN='your_token'", file=sys.stderr)
        print("  2. Argument: quip2markdown <url> --token <token>", file=sys.stderr)
        print("\nGet your token at: https://quip.com/dev/token", file=sys.stderr)
        sys.exit(1)

    # Extract thread ID from URL or use as-is
    thread_id = extract_thread_id(args.url_or_id)

    # Fetch HTML from Quip
    html_content = fetch_quip_html(thread_id, token)

    if not html_content:
        print("ERROR: No content returned from Quip", file=sys.stderr)
        sys.exit(1)

    # Convert to Markdown
    markdown = html_to_markdown(html_content)

    # Output to stdout
    print(markdown)


if __name__ == '__main__':
    main()
